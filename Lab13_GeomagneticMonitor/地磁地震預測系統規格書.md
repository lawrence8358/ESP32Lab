# 地磁地震預測系統 - 系統分析規格書

> **版本**: 1.0  
> **日期**: 2025-12-25  
> **作者**: Lawrence  

---

## 1. 系統概述

### 1.1 專案背景

地震發生前，地殼運動會導致地球磁場產生微小但可測量的變化。透過在不同地理位置部署多個地磁感測器節點，收集三軸地磁數據（X、Y、Z），並透過後端伺服器進行交叉運算與分析，可以預測地震發生的可能位置與強度。

### 1.2 系統架構圖

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           地磁地震預測系統架構                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌──────────────┐   ┌──────────────┐   ┌──────────────┐                    │
│  │ ESP32 節點 A │   │ ESP32 節點 B │   │ ESP32 節點 N │  ... (多節點)      │
│  │  (台南歸仁)  │   │  (台北市區)  │   │  (花蓮市區)  │                    │
│  │   BMM150     │   │   BMM150     │   │   BMM150     │                    │
│  │ GPS模組(選)  │   │ GPS模組(選)  │   │ GPS模組(選)  │                    │
│  └──────┬───────┘   └──────┬───────┘   └──────┬───────┘                    │
│         │                  │                  │                            │
│         │    MQTT / WiFi   │                  │                            │
│         └──────────────────┼──────────────────┘                            │
│                            ▼                                               │
│                   ┌─────────────────┐                                      │
│                   │   MQTT Broker   │                                      │
│                   │ (broker.emqx.io)│                                      │
│                   └────────┬────────┘                                      │
│                            │                                               │
│                            ▼                                               │
│               ┌────────────────────────┐                                   │
│               │    後端分析伺服器       │                                   │
│               │  - 數據接收與解密       │                                   │
│               │  - 時間序列分析         │                                   │
│               │  - 多節點交叉運算       │                                   │
│               │  - 地震位置預測         │                                   │
│               │  - 機器學習模型         │                                   │
│               └────────────┬───────────┘                                   │
│                            │                                               │
│              ┌─────────────┼─────────────┐                                 │
│              ▼             ▼             ▼                                 │
│        ┌──────────┐  ┌──────────┐  ┌──────────┐                           │
│        │ Web 前端 │  │ 手機 APP │  │LINE 通知 │                           │
│        │  (地圖)  │  │  (警報)  │  │  (推播)  │                           │
│        └──────────┘  └──────────┘  └──────────┘                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.3 核心功能

| 功能模組 | 說明 |
|---------|------|
| ESP32 感測節點 | 收集三軸地磁數據、計算磁場強度與羅盤角度、透過 MQTT 發送加密數據 |
| 後端分析伺服器 | 接收多節點數據、時間序列分析、交叉運算、地震預測演算法 |
| 前端展示系統 | 地圖視覺化、警報通知、歷史數據查詢 |

---

## 2. ESP32 感測節點規格

### 2.1 硬體需求

| 元件 | 型號 | 說明 |
|-----|------|------|
| 微控制器 | ESP32-WROOM-32 | 雙核心 240MHz，WiFi + BLE |
| 地磁感測器 | BMM150 (SEN0529) | 三軸地磁，精度 ±2.5°，範圍 ±1300μT |
| GPS 模組 (選配) | NEO-6M / ATGM336H | 用於自動取得經緯度（若位置固定可省略） |
| OLED 顯示 (選配) | SSD1306 128x64 | 本地狀態顯示 |
| 電源 | 5V/2A USB 或鋰電池 | 穩定供電 |

### 2.2 接線圖

```
ESP32                BMM150
─────                ──────
3.3V  ────────────── VCC
GND   ────────────── GND  
GPIO22 (SCL) ─────── SCL
GPIO21 (SDA) ─────── SDA
```

### 2.3 軟體模組架構

```
Lab_GeomagneticMonitor/
├── Lab_GeomagneticMonitor.ino    # 主程式
├── Bmm150Controller.h/.cpp       # BMM150 感測器封裝
├── WiFiController.h/.cpp         # WiFi 連線管理
├── MqttController.h/.cpp         # MQTT 通訊封裝
├── OlcdController.h/.cpp         # OLED 顯示 (選配)
├── Elgamal.h/.cpp                # Elgamal 加密
├── GeomagneticData.h             # 地磁數據結構定義
└── Config.h                      # 配置常數
```

---

## 3. 數據格式規格

### 3.1 原始地磁數據結構

```cpp
/**
 * 地磁感測數據結構
 * 由 ESP32 節點產生，透過 MQTT 發送至後端
 */
struct GeomagneticPayload {
    // === 節點識別 ===
    uint32_t chipId;          // ESP32 晶片唯一 ID
    char     nodeId[32];      // 節點名稱 (如 "TainanGuiren01")
    
    // === 地理位置 ===
    double   latitude;        // 緯度 (度)，如 22.9697
    double   longitude;       // 經度 (度)，如 120.2630
    float    altitude;        // 海拔高度 (公尺)
    
    // === 三軸地磁原始數據 (微特斯拉 μT) ===
    float    magX;            // X軸地磁分量 (水平向北為正)
    float    magY;            // Y軸地磁分量 (水平向東為正)
    float    magZ;            // Z軸地磁分量 (垂直向下為正)
    
    // === 計算衍生數據 ===
    float    magTotal;        // 總磁場強度 = √(X² + Y² + Z²)
    float    magHorizontal;   // 水平磁場強度 = √(X² + Y²)
    float    compassDegree;   // 羅盤角度 (0°=北, 順時針)
    float    inclination;     // 磁傾角 (度)
    float    declination;     // 磁偏角 (度)，需配合GPS計算
    
    // === 變化率數據 (與前一筆比較) ===
    float    deltaX;          // X軸變化量
    float    deltaY;          // Y軸變化量
    float    deltaZ;          // Z軸變化量
    float    deltaTotal;      // 總磁場變化量
    float    deltaRate;       // 變化速率 (μT/秒)
    
    // === 統計數據 (滑動視窗) ===
    float    avgX;            // X軸平均值 (過去N筆)
    float    avgY;            // Y軸平均值
    float    avgZ;            // Z軸平均值
    float    stdDevX;         // X軸標準差
    float    stdDevY;         // Y軸標準差
    float    stdDevZ;         // Z軸標準差
    float    variance;        // 總變異數
    
    // === 時間戳記 ===
    uint64_t timestamp;       // Unix timestamp (毫秒)
    uint32_t sampleIndex;     // 樣本序號 (從開機累計)
    uint16_t sampleRate;      // 採樣率 (Hz)
    
    // === 系統狀態 ===
    uint8_t  sensorStatus;    // 0=正常, 1=校準中, 2=異常
    int8_t   rssi;            // WiFi 訊號強度
    float    temperature;     // 感測器溫度 (部分BMM150支援)
};
```

### 3.2 JSON 傳輸格式

#### 3.2.1 標準數據封包 (Type: 200)

```json
{
    "Type": 200,
    "Version": "1.0",
    "ChipId": 12345678,
    "NodeId": "TainanGuiren01",
    "Timestamp": 1735084800000,
    "SampleIndex": 158432,
    
    "Location": {
        "Lat": 22.9697,
        "Lng": 120.2630,
        "Alt": 25.5
    },
    
    "Magnetic": {
        "X": 23.45,
        "Y": -5.12,
        "Z": 41.23,
        "Total": 47.89,
        "Horizontal": 24.00,
        "Compass": 167.5,
        "Inclination": 35.2
    },
    
    "Delta": {
        "X": 0.12,
        "Y": -0.08,
        "Z": 0.15,
        "Total": 0.21,
        "Rate": 0.42
    },
    
    "Stats": {
        "Window": 100,
        "AvgX": 23.40,
        "AvgY": -5.10,
        "AvgZ": 41.20,
        "StdX": 0.15,
        "StdY": 0.12,
        "StdZ": 0.18,
        "Variance": 0.0315
    },
    
    "System": {
        "Status": 0,
        "RSSI": -65,
        "Temp": 28.5,
        "SampleRate": 10
    }
}
```

#### 3.2.2 加密傳輸格式 (使用 Elgamal)

```json
{
    "Type": 201,
    "ChipId": "<加密的ChipId>",
    "X": "<Elgamal X值>",
    "Payload": "<Base64編碼的加密JSON>"
}
```

#### 3.2.3 異常警報封包 (Type: 210)

```json
{
    "Type": 210,
    "ChipId": 12345678,
    "Timestamp": 1735084800000,
    "AlertLevel": 2,
    "AlertType": "MAGNETIC_ANOMALY",
    "Message": "磁場變化超過閾值",
    "Data": {
        "DeltaTotal": 5.23,
        "Threshold": 2.0,
        "Duration": 3500
    }
}
```

### 3.3 數據欄位詳細說明

#### 3.3.1 三軸地磁數據

| 欄位 | 單位 | 範圍 | 說明 |
|-----|------|------|------|
| magX | μT | ±1300 | X軸（水平向北）地磁分量 |
| magY | μT | ±1300 | Y軸（水平向東）地磁分量 |
| magZ | μT | ±2500 | Z軸（垂直向下）地磁分量 |
| magTotal | μT | 20~70 | 地球磁場總強度（台灣約 45μT） |
| magHorizontal | μT | 20~40 | 水平分量強度 |

#### 3.3.2 羅盤與角度

| 欄位 | 單位 | 範圍 | 說明 |
|-----|------|------|------|
| compassDegree | 度 | 0~360 | 羅盤方位角（0°=北，順時針） |
| inclination | 度 | -90~+90 | 磁傾角（台灣約 +35°） |
| declination | 度 | -180~+180 | 磁偏角（真北與磁北差異） |

#### 3.3.3 變化率數據

| 欄位 | 單位 | 說明 |
|-----|------|------|
| deltaX/Y/Z | μT | 與前一筆採樣的差值 |
| deltaTotal | μT | 總磁場變化量 |
| deltaRate | μT/s | 每秒變化速率（重要預測指標） |

#### 3.3.4 統計數據

| 欄位 | 說明 |
|-----|------|
| avgX/Y/Z | 滑動視窗內的平均值（預設100筆） |
| stdDevX/Y/Z | 標準差，用於判斷異常波動 |
| variance | 總變異數，異常偵測的重要指標 |

---

## 4. ESP32 程式實作規格

### 4.1 配置常數 (Config.h)

```cpp
#ifndef CONFIG_H
#define CONFIG_H

// ============ 節點配置 ============
#define NODE_ID           "TainanGuiren01"    // 節點唯一名稱
#define NODE_LATITUDE     22.9697             // 緯度
#define NODE_LONGITUDE    120.2630            // 經度
#define NODE_ALTITUDE     25.5                // 海拔 (公尺)

// ============ WiFi 配置 ============
#define WIFI_SSID         "YourSSID"
#define WIFI_PASSWORD     "YourPassword"

// ============ MQTT 配置 ============
#define MQTT_BROKER       "broker.emqx.io"
#define MQTT_PORT         1883
#define MQTT_TOPIC_DATA   "geomagnetic/data"
#define MQTT_TOPIC_ALERT  "geomagnetic/alert"
#define MQTT_TOPIC_KEY    "geomagnetic/key"

// ============ 採樣配置 ============
#define SAMPLE_RATE_HZ    10                  // 採樣頻率 (Hz)
#define SAMPLE_INTERVAL   (1000 / SAMPLE_RATE_HZ)  // 採樣間隔 (ms)
#define STATS_WINDOW_SIZE 100                 // 統計視窗大小
#define SEND_INTERVAL_MS  1000                // MQTT 發送間隔 (ms)

// ============ 異常偵測閾值 ============
#define ALERT_DELTA_THRESHOLD   2.0           // 磁場變化閾值 (μT)
#define ALERT_STDDEV_THRESHOLD  1.5           // 標準差閾值 (μT)
#define ALERT_DURATION_MS       3000          // 異常持續時間閾值 (ms)

// ============ 加密配置 ============
#define USE_ENCRYPTION    true                // 是否啟用 Elgamal 加密

// ============ 硬體配置 ============
#define BMM150_I2C_ADDR   I2C_ADDRESS_4       // 0x13
#define I2C_SDA_PIN       21
#define I2C_SCL_PIN       22
#define OLED_ENABLED      true
#define LED_STATUS_PIN    2                   // 內建 LED

#endif // CONFIG_H
```

### 4.2 地磁數據結構 (GeomagneticData.h)

```cpp
#ifndef GEOMAGNETIC_DATA_H
#define GEOMAGNETIC_DATA_H

#include <Arduino.h>
#include <ArduinoJson.h>
#include <math.h>

/**
 * 滑動視窗統計計算器
 */
class SlidingWindowStats {
public:
    SlidingWindowStats(size_t windowSize = 100);
    
    void addSample(float x, float y, float z);
    
    float getAvgX() const { return _avgX; }
    float getAvgY() const { return _avgY; }
    float getAvgZ() const { return _avgZ; }
    float getStdDevX() const { return sqrt(_varX); }
    float getStdDevY() const { return sqrt(_varY); }
    float getStdDevZ() const { return sqrt(_varZ); }
    float getVariance() const { return (_varX + _varY + _varZ) / 3.0f; }
    size_t getSampleCount() const { return _count; }
    
private:
    size_t _windowSize;
    size_t _count;
    float* _bufferX;
    float* _bufferY;
    float* _bufferZ;
    size_t _index;
    float _avgX, _avgY, _avgZ;
    float _varX, _varY, _varZ;
    
    void recalculate();
};

/**
 * 地磁數據封包
 */
struct GeomagneticPacket {
    // 節點資訊
    uint32_t chipId;
    String nodeId;
    
    // 位置
    double latitude;
    double longitude;
    float altitude;
    
    // 原始磁場數據
    float magX;
    float magY;
    float magZ;
    
    // 計算值
    float magTotal;
    float magHorizontal;
    float compassDegree;
    float inclination;
    
    // 變化量
    float deltaX;
    float deltaY;
    float deltaZ;
    float deltaTotal;
    float deltaRate;
    
    // 統計值
    float avgX, avgY, avgZ;
    float stdDevX, stdDevY, stdDevZ;
    float variance;
    
    // 時間與狀態
    uint64_t timestamp;
    uint32_t sampleIndex;
    uint16_t sampleRate;
    uint8_t sensorStatus;
    int8_t rssi;
    
    /**
     * 計算衍生數據
     */
    void calculate() {
        magTotal = sqrt(magX*magX + magY*magY + magZ*magZ);
        magHorizontal = sqrt(magX*magX + magY*magY);
        inclination = atan2(magZ, magHorizontal) * 180.0 / PI;
    }
    
    /**
     * 計算與前一筆的變化量
     */
    void calculateDelta(const GeomagneticPacket& prev, uint32_t intervalMs) {
        deltaX = magX - prev.magX;
        deltaY = magY - prev.magY;
        deltaZ = magZ - prev.magZ;
        deltaTotal = sqrt(deltaX*deltaX + deltaY*deltaY + deltaZ*deltaZ);
        deltaRate = deltaTotal / (intervalMs / 1000.0f);
    }
    
    /**
     * 序列化為 JSON
     */
    String toJson() const {
        StaticJsonDocument<1024> doc;
        
        doc["Type"] = 200;
        doc["Version"] = "1.0";
        doc["ChipId"] = chipId;
        doc["NodeId"] = nodeId;
        doc["Timestamp"] = timestamp;
        doc["SampleIndex"] = sampleIndex;
        
        JsonObject loc = doc.createNestedObject("Location");
        loc["Lat"] = latitude;
        loc["Lng"] = longitude;
        loc["Alt"] = altitude;
        
        JsonObject mag = doc.createNestedObject("Magnetic");
        mag["X"] = round2(magX);
        mag["Y"] = round2(magY);
        mag["Z"] = round2(magZ);
        mag["Total"] = round2(magTotal);
        mag["Horizontal"] = round2(magHorizontal);
        mag["Compass"] = round2(compassDegree);
        mag["Inclination"] = round2(inclination);
        
        JsonObject delta = doc.createNestedObject("Delta");
        delta["X"] = round2(deltaX);
        delta["Y"] = round2(deltaY);
        delta["Z"] = round2(deltaZ);
        delta["Total"] = round2(deltaTotal);
        delta["Rate"] = round2(deltaRate);
        
        JsonObject stats = doc.createNestedObject("Stats");
        stats["Window"] = STATS_WINDOW_SIZE;
        stats["AvgX"] = round2(avgX);
        stats["AvgY"] = round2(avgY);
        stats["AvgZ"] = round2(avgZ);
        stats["StdX"] = round2(stdDevX);
        stats["StdY"] = round2(stdDevY);
        stats["StdZ"] = round2(stdDevZ);
        stats["Variance"] = round4(variance);
        
        JsonObject sys = doc.createNestedObject("System");
        sys["Status"] = sensorStatus;
        sys["RSSI"] = rssi;
        sys["SampleRate"] = sampleRate;
        
        String output;
        serializeJson(doc, output);
        return output;
    }
    
private:
    static float round2(float v) { return round(v * 100) / 100.0f; }
    static float round4(float v) { return round(v * 10000) / 10000.0f; }
};

#endif // GEOMAGNETIC_DATA_H
```

### 4.3 主程式框架

```cpp
// Lab_GeomagneticMonitor.ino
#include "Config.h"
#include "Bmm150Controller.h"
#include "WiFiController.h"
#include "MqttController.h"
#include "OlcdController.h"
#include "Elgamal.h"
#include "GeomagneticData.h"

// ============ 全域變數 ============
GeomagneticPacket currentPacket;
GeomagneticPacket previousPacket;
SlidingWindowStats stats(STATS_WINDOW_SIZE);
Elgamal* elgamal = nullptr;

uint32_t sampleIndex = 0;
unsigned long lastSampleTime = 0;
unsigned long lastSendTime = 0;
unsigned long anomalyStartTime = 0;
bool inAnomalyState = false;

TaskHandle_t NetworkTaskHandle;

// ============ Setup ============
void setup() {
    Serial.begin(115200);
    delay(1000);
    
    initializeNode();
    initializeSensor();
    initializeNetwork();
    
    // 網路任務在 Core 0 執行
    xTaskCreatePinnedToCore(
        networkTask, "NetworkTask", 10000, NULL, 0, &NetworkTaskHandle, 0
    );
}

// ============ Loop (Core 1) ============
void loop() {
    unsigned long now = millis();
    
    // 按照採樣率讀取數據
    if (now - lastSampleTime >= SAMPLE_INTERVAL) {
        lastSampleTime = now;
        
        readSensorData();
        calculateDerivedData();
        updateStatistics();
        checkAnomalies();
        updateDisplay();
    }
}

// ============ 網路任務 (Core 0) ============
void networkTask(void* param) {
    for (;;) {
        // WiFi 重連
        WIFI.reconnect();
        
        // MQTT 維護
        if (WIFI.connected()) {
            MQTT.connect();
            MQTT.loop();
        }
        
        // 定期發送數據
        unsigned long now = millis();
        if (now - lastSendTime >= SEND_INTERVAL_MS) {
            lastSendTime = now;
            sendData();
        }
        
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

// ============ 初始化函式 ============
void initializeNode() {
    currentPacket.chipId = getChipId();
    currentPacket.nodeId = NODE_ID;
    currentPacket.latitude = NODE_LATITUDE;
    currentPacket.longitude = NODE_LONGITUDE;
    currentPacket.altitude = NODE_ALTITUDE;
    currentPacket.sampleRate = SAMPLE_RATE_HZ;
}

void initializeSensor() {
    if (!BMM150.init(BMM150_PRESETMODE_HIGHACCURACY, BMM150_DATA_RATE_30HZ)) {
        Serial.println("BMM150 初始化失敗!");
        while (true) delay(1000);
    }
    Serial.println("BMM150 初始化成功!");
}

void initializeNetwork() {
    #if OLED_ENABLED
    OLCD.init();
    OLCD.print("Initializing...");
    #endif
    
    WIFI.connect();
    MQTT.init();
    MQTT.receive(mqttCallback);
}

// ============ 數據處理函式 ============
void readSensorData() {
    previousPacket = currentPacket;
    
    sBmm150MagData_t magData = BMM150.readMagData();
    
    currentPacket.magX = magData.x;
    currentPacket.magY = magData.y;
    currentPacket.magZ = magData.z;
    currentPacket.compassDegree = BMM150.readCompassDegree();
    currentPacket.timestamp = getTimestamp();
    currentPacket.sampleIndex = ++sampleIndex;
    currentPacket.rssi = WiFi.RSSI();
    currentPacket.sensorStatus = 0;
}

void calculateDerivedData() {
    currentPacket.calculate();
    currentPacket.calculateDelta(previousPacket, SAMPLE_INTERVAL);
}

void updateStatistics() {
    stats.addSample(currentPacket.magX, currentPacket.magY, currentPacket.magZ);
    
    currentPacket.avgX = stats.getAvgX();
    currentPacket.avgY = stats.getAvgY();
    currentPacket.avgZ = stats.getAvgZ();
    currentPacket.stdDevX = stats.getStdDevX();
    currentPacket.stdDevY = stats.getStdDevY();
    currentPacket.stdDevZ = stats.getStdDevZ();
    currentPacket.variance = stats.getVariance();
}

void checkAnomalies() {
    bool isAnomaly = 
        currentPacket.deltaTotal > ALERT_DELTA_THRESHOLD ||
        currentPacket.stdDevX > ALERT_STDDEV_THRESHOLD ||
        currentPacket.stdDevY > ALERT_STDDEV_THRESHOLD ||
        currentPacket.stdDevZ > ALERT_STDDEV_THRESHOLD;
    
    if (isAnomaly && !inAnomalyState) {
        anomalyStartTime = millis();
        inAnomalyState = true;
    } else if (!isAnomaly) {
        inAnomalyState = false;
    }
    
    // 異常持續超過閾值時發送警報
    if (inAnomalyState && (millis() - anomalyStartTime > ALERT_DURATION_MS)) {
        sendAlert();
        inAnomalyState = false;  // 避免重複發送
    }
}

void sendData() {
    if (!MQTT.connected()) return;
    
    String payload = currentPacket.toJson();
    
    #if USE_ENCRYPTION
    if (elgamal != nullptr) {
        payload = encryptPayload(payload);
    }
    #endif
    
    MQTT.publish(payload.c_str());
    
    // LED 閃爍表示發送
    digitalWrite(LED_STATUS_PIN, HIGH);
    delay(50);
    digitalWrite(LED_STATUS_PIN, LOW);
}

void sendAlert() {
    StaticJsonDocument<512> doc;
    doc["Type"] = 210;
    doc["ChipId"] = currentPacket.chipId;
    doc["Timestamp"] = currentPacket.timestamp;
    doc["AlertLevel"] = 2;
    doc["AlertType"] = "MAGNETIC_ANOMALY";
    doc["Message"] = "磁場變化超過閾值";
    
    JsonObject data = doc.createNestedObject("Data");
    data["DeltaTotal"] = currentPacket.deltaTotal;
    data["Threshold"] = ALERT_DELTA_THRESHOLD;
    data["Duration"] = millis() - anomalyStartTime;
    
    String payload;
    serializeJson(doc, payload);
    
    // 發送到警報主題
    // MQTT.publish(MQTT_TOPIC_ALERT, payload.c_str());
}

void updateDisplay() {
    #if OLED_ENABLED
    String line1 = WIFI.connected() ? "Online" : "Offline";
    String line2 = String("X:") + String(currentPacket.magX, 1) + 
                   " Y:" + String(currentPacket.magY, 1);
    String line3 = String("Z:") + String(currentPacket.magZ, 1) + 
                   " T:" + String(currentPacket.magTotal, 1);
    OLCD.print(line1, line2, line3);
    #endif
}

// ============ MQTT 回調 ============
void mqttCallback(String topic, String message) {
    // 處理 Elgamal 公鑰
    if (message.startsWith("g=")) {
        parseElgamalKey(message);
    }
}

void parseElgamalKey(const String& message) {
    int gIndex = message.indexOf("g=");
    int pIndex = message.indexOf("p=");
    int YIndex = message.indexOf("Y=");
    
    if (gIndex >= 0 && pIndex > 0 && YIndex > 0) {
        uint64_t g = atoll(message.substring(2, pIndex - 1).c_str());
        uint64_t p = atoll(message.substring(pIndex + 2, YIndex - 1).c_str());
        uint64_t Y = atoll(message.substring(YIndex + 2).c_str());
        
        if (elgamal != nullptr) delete elgamal;
        elgamal = new Elgamal(p, g);
        
        Serial.printf("Elgamal Key received: G=%llu, P=%llu, Y=%llu\n", g, p, Y);
    }
}

// ============ 工具函式 ============
uint32_t getChipId() {
    uint32_t chipId = 0;
    for (int i = 0; i < 17; i += 8) {
        chipId |= ((ESP.getEfuseMac() >> (40 - i)) & 0xff) << i;
    }
    return chipId;
}

uint64_t getTimestamp() {
    // 簡化版：使用 millis()，實際應用建議使用 NTP 時間
    return millis();
}
```

---

## 5. 後端接收規格

### 5.1 數據接收介面

後端伺服器需實作以下功能：

| 功能 | 說明 |
|-----|------|
| MQTT 訂閱 | 訂閱 `geomagnetic/data` 和 `geomagnetic/alert` 主題 |
| 數據解析 | 解析 JSON 格式的地磁數據封包 |
| Elgamal 解密 | 解密加密的數據封包 |
| 數據儲存 | 寫入時序資料庫（如 InfluxDB、TimescaleDB） |
| 即時分析 | 多節點交叉運算與地震預測 |

### 5.2 預期接收數據範例

```json
{
    "Type": 200,
    "Version": "1.0",
    "ChipId": 12345678,
    "NodeId": "TainanGuiren01",
    "Timestamp": 1735084800000,
    "SampleIndex": 158432,
    "Location": { "Lat": 22.9697, "Lng": 120.2630, "Alt": 25.5 },
    "Magnetic": {
        "X": 23.45, "Y": -5.12, "Z": 41.23,
        "Total": 47.89, "Horizontal": 24.00,
        "Compass": 167.5, "Inclination": 35.2
    },
    "Delta": { "X": 0.12, "Y": -0.08, "Z": 0.15, "Total": 0.21, "Rate": 0.42 },
    "Stats": {
        "Window": 100,
        "AvgX": 23.40, "AvgY": -5.10, "AvgZ": 41.20,
        "StdX": 0.15, "StdY": 0.12, "StdZ": 0.18,
        "Variance": 0.0315
    },
    "System": { "Status": 0, "RSSI": -65, "SampleRate": 10 }
}
```

### 5.3 多節點交叉運算建議

| 演算法 | 說明 |
|-------|------|
| 時間同步分析 | 比較不同節點在相同時間點的磁場變化 |
| 空間三角定位 | 根據多節點的異常訊號強度和時間差計算震央 |
| 波形傳播分析 | 追蹤磁場異常從一個節點傳播到另一個節點的模式 |
| 統計異常偵測 | 使用 Z-Score 或 IQR 識別異常數據點 |
| 機器學習預測 | 訓練模型識別地震前兆的磁場特徵 |

---

## 6. 附錄

### 6.1 地磁參考數據（台灣）

| 地區 | 緯度 | 經度 | 總磁場 (μT) | 磁傾角 (°) | 磁偏角 (°) |
|-----|------|------|------------|-----------|-----------|
| 台北 | 25.03 | 121.57 | 45.5 | 35.5 | -3.5 |
| 台中 | 24.15 | 120.67 | 45.2 | 34.8 | -3.2 |
| 台南 | 22.99 | 120.20 | 44.8 | 33.5 | -2.8 |
| 花蓮 | 23.99 | 121.60 | 45.0 | 34.2 | -3.0 |

### 6.2 Type 代碼對照表

| Type | 說明 |
|------|------|
| 200 | 標準地磁數據封包 |
| 201 | 加密地磁數據封包 |
| 210 | 異常警報封包 |
| 220 | 節點狀態封包 |
| 230 | 校準數據封包 |

### 6.3 錯誤代碼

| Status | 說明 |
|--------|------|
| 0 | 正常運作 |
| 1 | 感測器校準中 |
| 2 | 感測器異常 |
| 3 | WiFi 連線異常 |
| 4 | MQTT 連線異常 |

---

## 7. 開發里程碑

| 階段 | 內容 | 預估時間 |
|-----|------|---------|
| Phase 1 | ESP32 單節點數據收集與發送 | 1 週 |
| Phase 2 | 後端接收與數據儲存 | 1 週 |
| Phase 3 | 多節點部署與數據同步 | 2 週 |
| Phase 4 | 交叉運算與預測演算法 | 3 週 |
| Phase 5 | 前端展示與警報系統 | 2 週 |
| Phase 6 | 測試與優化 | 2 週 |

---

**文件結束**

如有任何問題或需要進一步說明，請隨時提出。
